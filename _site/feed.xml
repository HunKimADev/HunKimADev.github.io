<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-02T16:56:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hoolie’s Tech Blog</title><subtitle>공부하고 까먹지 않기 위해 정리해 나가는 개발 블로그</subtitle><entry><title type="html">취업 후기</title><link href="http://localhost:4000/daily/2022/02/02/%EC%B7%A8%EC%97%85-%ED%9B%84%EA%B8%B0.html" rel="alternate" type="text/html" title="취업 후기" /><published>2022-02-02T00:00:00+09:00</published><updated>2022-02-02T00:00:00+09:00</updated><id>http://localhost:4000/daily/2022/02/02/%EC%B7%A8%EC%97%85%20%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/daily/2022/02/02/%EC%B7%A8%EC%97%85-%ED%9B%84%EA%B8%B0.html"><![CDATA[<p><br /></p>

<p>코드스테이츠 수료 후 어언 5개월, 우여곡절 끝에 백엔드 개발자로 취업에 성공했습니다.<br />
오늘은 그 취업 후기에 대한 블로그를 적어보려고 합니다.</p>

<p><br /></p>

<h3 id="취업-준비"><strong>취업 준비</strong></h3>
<hr />
<p><br /></p>

<p><strong><code class="language-plaintext highlighter-rouge">CS지식</code></strong>: 제가 게으른 탓이 크겠지만, 무턱대고 CS지식 전체를 공부하기엔 막연해서 우선은 무작정 지원하고 면접을 봤습니다.
그 후에 그 면접에서 대답하지 못했던 질문들 위주로 정리하고 공부해서 다음 면접에 임하는 방식으로 준비를 했죠. 확실히 신입 개발자에게 하는 CS지식 관련 질문들은 한정적이기 때문에 5번째 6번째 정도의 면접부터는 대부분의 질문들에 대답할 수 있게 되었습니다.</p>

<p><br /></p>

<p><strong><code class="language-plaintext highlighter-rouge">알고리즘</code></strong>: 알고리즘은 프로그래머스 기준 레벨 1, 2 위주로 많이 풀어 봤습니다. 네이버나 카카오 공채같은 경우엔 커트라인이 프로그래머스 레벨 3 문제를 풀 수 있는 정도인 것 같지만, 스타트업 기준으로는 프로그래머스 레벨 1, 2 수준의 문제를 원활하게 풀 정도면 코딩테스트에서 떨어질 일은 드물 것 같습니다.</p>

<p><br /></p>

<p><strong><code class="language-plaintext highlighter-rouge">경험 정리</code></strong>: 그동안 해왔던 프로젝트에 대해서, 특히 이력서 상으로 제일 최근에 진행한 프로젝트에 관해서 해당 프로젝트가 어떤 프로젝트였는지,
프로젝트의 구성원과, 나는 어떤 역할을 했는지, 어떤 기능들을 개발했는지, 협업 방식은 어땠는지, 해당 기술스택을 선택한 이유는 무엇인지 등등 최대한 디테일하게 정리를 하고 면접에 임하는게 중요한 것 같습니다. 물론 면접을 보면 볼수록 알아서 느는 부분이기도 하죠. 면접을 계속 보다보니 처음 면접 볼 땐 횡설수설하던 내가 어느샌가 해당 프로젝트의 영업사원마냥 청산유수로 설명하고 있는걸 발견할 수 있었습니다.</p>

<p><br /></p>

<p><strong><code class="language-plaintext highlighter-rouge">사이드 프로젝트</code></strong>: 수료 후 사이드 프로젝트는 따로 하지 않고, 그때 그때 도움이 필요한 사람이 있으면 가서 도와주기만 했습니다.
아마 저만의 사이드 프로젝트를 했으면 취업 준비 기간이 더욱 더 단축됐을 것 같네요. 프로젝트의 퀄리티에 따라 다르겠지만 ‘학교나 수업 과정에서 해야만 해서 진행한’ 프로젝트가 아닌 ‘스스로의 흥미로 시작한’ 프로젝트는 그 사람의 개발에 대한 열정을 가장 잘 보여줄 수 있는 척도이기 때문에 면접관 분들 또는 회사들에게 가장 크게 어필할 수 있는 부분이 아닐까 생각합니다.</p>

<p><br />
<br /></p>

<h3 id="채용-과정"><strong>채용 과정</strong></h3>
<hr />
<p><br /></p>

<p>저번 주에 A사, B사, C사 총 3곳으로부터 ‘백엔드 개발자’ 포지션으로 오퍼를 받았고, 이 회사들의 채용 과정에 대해 정리해봤습니다.</p>

<p><br /></p>

<h4 id="1-a사---20명-안팎의-초기-스타트업-회사"><strong>1. A사:</strong> - 20명 안팎의 초기 스타트업 회사</h4>

<p><strong>채용 과정</strong>: 서류 -&gt; <strong><code class="language-plaintext highlighter-rouge">1차 기술 면접 -&gt; 2차 fit 면접</code></strong> -&gt; <strong><code class="language-plaintext highlighter-rouge">과제 전형</code></strong> -&gt; 최종 합격</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">1차 기술면접 &amp; 2차 fit 면접</code></strong>: CEO님과 Dev팀 리드님과 함께한 2:1 면접이었습니다. 이력서에 대한 질문 사항들, 최근 프로젝트와 이력서에 표기되지 않은 이전에 진행 해본 <strong>1)프로젝트들에 대한 질문</strong>을 시작으로, 평소 개발자로서 실력을 키우기 위해 어떤 노력들을 하는지, <strong>2)성장에 대한 열정</strong>을 알아보기 위한 질문들이 나왔고, 마지막으로는 <strong>3)기초적인 CS 질문들</strong>로 기술관련 질문은 마무리 되었고, 그 이후에 <strong>4)개발을 하면서 가장 중요하게 생각하는 부분</strong>이 무엇인지, <strong>5)같이 일하기 싫은 사람은 어떤 유형</strong>의 사람인지 등에 대한 질문들이 나왔습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">과제 전형</code></strong>: 백엔드 관련 과제 3문제를 정해진 시간에 관련 노션링크로 초대해 주셔서 6시간 안에 각 문제를 <strong>1)어떻게 해결할지 작성</strong>하고, 문제를 해결한 뒤 해당 문제에 대한 <strong>2)회고까지 문서로 작성</strong>해서 <strong>3)해결한 코드와 함께 깃헙으로 제출</strong>하는 형식이었고, 처음 접해보는 문제였지만 검색을 통해 충분히 해결할 수 있는 문제였습니다.
그동안 경험해봤던 혹은 들어봤던 다른 과제전형에 비해 시간이 여유롭지 않아 걱정했지만, 걱정한 것 보다는 난이도도 괜찮았고, 그동안 써보지 못한 개념도 배우고, 즐거운 과제전형이었습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">후기</code></strong>: 체계적인 개발 문화(코드리뷰 등)가 있는지에 대한 질문에, 아직 너무 초기의 스타트업이다 보니, 코드 퀄리티나 체계적인 문화보다는 ‘생존’에 더 초점을 맞추고 있다라는 대답을 해주셔서 걱정이 매우 커졌지만, 초기 스타트업이긴 하나 Node.js 코어를 이용한 서버 구축과 AWS인프라 관련해서는 다른 보통의 스타트업보다 잘 알고 많이 가르쳐줄 수 있다 라는 자신감을 보여주신 점이 좋았습니다. 하지만 앞서 대답해 주신 ‘체계가 제대로 잡히지 않은 점’과 같이 일하게 될 ‘백엔드 개발자가 한 명뿐’이라는 것이 고민되는 부분이었습니다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="2-b사---180명-안팎의-성장-중인-스타트업-회사-series-c"><strong>2. B사:</strong> - 180명 안팎의 성장 중인 스타트업 회사 (Series C)</h4>

<p><strong>채용 과정</strong>: 서류 -&gt; <strong><code class="language-plaintext highlighter-rouge">코딩테스트</code></strong> -&gt; <strong><code class="language-plaintext highlighter-rouge">과제 전형</code></strong> -&gt; <strong><code class="language-plaintext highlighter-rouge">대면 면접</code></strong> -&gt; 최종 합격</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">코딩테스트</code></strong> : 해당 회사의 현직 개발자 분이 직접 출제하신 알고리즘 문제 3개를 프로그래머스 플랫폼에서 푸는 형식이었습니다. 난이도는 <strong>프로그래머스 기준 레벨 1, 2</strong> 정도로 스택, 큐 등 기본적인 자료구조 알고리즘으로 해결 할 수 있는 문제들이었습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">과제 전형</code></strong>: 어떠한 서비스와 상황을 내어준 뒤, 해당 서비스와 상황에 맞는 <strong>DB 스키마를 설계</strong>해오는 과제였습니다. <a href="https://dbdiagram.io/home">dbdiagram.io</a>로 스키마를 설계 후 제출했으며, 해당 회사의 서비스에서 실제로 사용할 것 같은 상황이 주어졌어서 재미있게 풀 수 있었습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">대면 면접</code></strong>: CTO님과 같이 일하게 될 백엔드 개발자 두 분, 3:1로 진행된 면접이었습니다. 먼저 코딩테스트는 어땠는지에 대한 이야기(여기서 출제자 분이 실시간으로 제가 풀고있는걸 보셨다는걸 알게 되었습니다 ;-;..), 과제에 대한 리뷰 - 왜 이런식으로 설계를 했는지 등에 대해 토론 후 기술 면접으로 들어갔는데, A사와 마찬가지로 <strong>프로젝트 관련 질문</strong>(구현 방식이나 동작 방식에 대한 질문 등 더욱 더 디테일한), <strong>CS관련 질문</strong> 등을 해주셨습니다. 이 회사의 CS관련 질문이 좋았던 점은 랜덤한 기초 CS지식에 기반해서 질문한 것이 아니라 제가 <strong>진행했던 프로젝트에서 사용한 기술을 기반으로 질문</strong>을 해주신 점이었습니다. 뿐만아니라 지금 <strong>회사에서 현재 기술적으로 고민하고 있는 부분</strong>, 혹은 <strong>고민한 뒤 해결했던 문제들</strong>에 대해 해당 상황에서 어떻게 해결할건지 질문을 해주시고, 함께 고민도 해보는 등 경험해보지 못한 기술들에 대해 생각해보고 배울 수 있었고, 전반적으로 편안하고 재밌는 분위기의 면접이었습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">후기</code></strong>: 사실 이 회사는 코드스테이츠를 통해 3개월 전에 면접을 봤던 회사였고, 당시 경력 개발자 분을 모시는 중이었어서 면접에서 탈락했던 회사였습니다. 그런데 지난주 시리즈C를 마무리하고, 새로 신입개발자 TO가 나면서 제가 생각나서 혹시 아직 구직중이거나, 이직 생각중이면 연락 부탁드린다는 메일을 보내주셔서, 최종 합격 및 오퍼까지 진행된 경우입니다. 초반을 넘어선 규모가 상당히 큰 중반의 성장중인 스타트업으로서 기존의 레거시코드를 옮기는 작업과, 새로운 API개발 작업, 신사업 인프라 작업 등 충분히 다양한 경험을 해볼 수 있다는 점과 그 무엇보다 면접경험이 너무 좋았기 때문에, 같이 일할 사람들이 좋은 사람들이다라는 점이 제일 큰 매력으로 다가온 회사였습니다. 무엇보다 3개월이 지났는데 다시 연락해서 저를 찾아주신게 너무 감사했던 회사였죠.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="3-c사---300명-안팎의-글로벌-진출을-준비중인-스타트업-회사series-b"><strong>3. C사:</strong> - 300명 안팎의 글로벌 진출을 준비중인 스타트업 회사(Series B)</h4>

<p><strong>채용 과정</strong>: 서류(소개) -&gt; <strong><code class="language-plaintext highlighter-rouge">코딩테스트</code></strong> -&gt; <strong><code class="language-plaintext highlighter-rouge">라이브 코딩 면접</code></strong> -&gt; 최종 합격</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">코딩테스트</code></strong>: <strong>Codility</strong> 플랫폼을 통해 <strong>3문제</strong>를 풀어야하는 코딩테스트였습니다. 해외 플랫폼이기 때문에 문제는 영어로 되어있었지만, 문제의 난이도는 제일 어려운 3번 문제가 <strong>프로그래머스 기준 레벨 1수준</strong>으로 상당히 쉬운 난이도였습니다. 문제 제출 후 바로 점수가 산출이 되는 방식이었기 때문에 마음도 아주 편한 코딩테스트 였습니다. :D</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">라이브 코딩 면접</code></strong>: CTO님과 1:1로 진행됐으며, 마찬가지로 Codility플랫폼에서 화상면접으로 진행되었습니다. 따로 문제가 준비되어 있는게 아니라, <strong>CTO님이 직접 문제를 제출해 주시고, 해당 문제를 어떻게 풀건지 같이 토론한 뒤, 코드로 작성하고, 검증하는 방식</strong>으로 한가지 문제를 3가지 방식으로 풀어보고, 그 문제를 더 발전시킨 문제를 또 두어가지 방식으로 풀어본 뒤 해당 방식들의 <strong>시간복잡도와 공간복잡도</strong>에 대해 이야기하는 방식의 라이브 코딩테스트였습니다.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">후기</code></strong>: 사실 이 회사는 엘리스코딩을 통해 <strong>율리님</strong>에게 면접제의가 간 회사였는데, 율리님이 저를 추천해주셔서 면접을 보게 된 케이스였습니다. 사실 면접을 보기 전에 회사에 대해 조사해봤을 때는 전,현직자들의 안좋은 이야기들이 많아 면접 경험만 쌓고 가지 않으려 했는데, 면접을 진행해주셨던 새로 오신 CTO분이(면접 당시에는 CTO분인지 몰랐습니다..) 현재 좋은 방향으로 많은 변화를 일으키고 있고, 면접을 진행하면서 이분에게 배울점이 너무 많을 것 같다는 느낌을 받아 최종적으로 이 회사로 결정하게 되었습니다. 
좀 더 자세히 얘기해 보자면, 면접 중에 해당 회사에 관련한 예민한 질문(퇴사율이 높은 이유 등)등을 하면서 이 회사에 온지 7개월 되셨다는 말에, 시니어 개발자로서(이 질문을 할때는 CTO분인지 몰랐어서..ㅋㅋ) 왜 이 회사를 선택하셨는가에 대한 질문에 대한 대답을 듣고, ‘이분과 함께 일해보고 배우고싶다’ 라는 생각이 들었고, 이 사람이라면 그동안 이 회사에 대해 조사하면서 본 안좋은 평가들을 뒤엎을 수 있겠구나 싶어서 최종적으로 이 회사를 선택하게 되었습니다.</p>
  </li>
</ul>

<p><br />
<br /></p>

<h3 id="마무리"><strong>마무리</strong></h3>
<hr />
<p><br /></p>

<p>무튼 이런 저런 우여곡절 끝에 취업에 성공하게 됐습니다.<br />
앞으로 매일 자기전에 율리님이 계신 방향으로 절 한 번씩 올리고 잠자리에 들 예정입니다.</p>]]></content><author><name></name></author><category term="Daily" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">RDBMS와 NoSQL의 차이 - 2부 NoSQL</title><link href="http://localhost:4000/cs/2022/01/26/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-2%EB%B6%80-NoSQL.html" rel="alternate" type="text/html" title="RDBMS와 NoSQL의 차이 - 2부 NoSQL" /><published>2022-01-26T00:00:00+09:00</published><updated>2022-01-26T00:00:00+09:00</updated><id>http://localhost:4000/cs/2022/01/26/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-2%EB%B6%80-NoSQL</id><content type="html" xml:base="http://localhost:4000/cs/2022/01/26/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-2%EB%B6%80-NoSQL.html"><![CDATA[<p>저번 포스팅에 이어 이번에는 NoSQL에 대해 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="nosql이란"><strong>NoSQL이란?</strong></h3>
<p><strong>N</strong>ot <strong>O</strong>nly <strong>SQL</strong> (SQL만을 사용하지 않는) 혹은 <strong>No</strong>n <strong>SQL</strong> (비 SQL)의 약자로 알려져 있습니다.<br />
NoSQL은 이름 그대로 관계형 데이터베이스와는 다른 방식으로 데이터를 저장하는 데이터베이스를 말합니다.
대용량 데이터 처리가 중요해짐에 따라 RDBMS의 한계점인 스키마 문제와 수직적 확장(스케일업)의 한계를 극복하기 위해 등장한 데이터베이스입니다.</p>

<p>NoSQL의 종류는 데이터를 어떤 방식으로 저장하느냐에 따라 나누어지는데 아래에서 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="nosql의-종류"><strong>NoSQL의 종류</strong></h3>

<h4 id="1-key-value-database--redis"><strong>1. Key-Value Database : Redis</strong></h4>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/5b/KeyValue.PNG" alt="key-value database" /><br />
<a href="https://en.wikipedia.org/wiki/Key%E2%80%93value_database">이미지 출처(wikipedia)</a></p>

<p>가장 간단한 형태의 NoSQL 데이터베이스로 모든 데이터가 Key-Value Pair로 저장됩니다.
구조가 단순한만큼 데이터의 처리 속도가 빠릅니다.</p>

<p><br /></p>

<h4 id="2-document-database--mongodb-couchdb"><strong>2. Document Database : MongoDB, CouchDB</strong></h4>
<p><img src="https://ravendb.net/wp-content/uploads/2021/04/beers-table-documents-1.png" alt="document database" /><br />
<a href="https://ravendb.net/articles/nosql-document-oriented-databases-detailed-overview">이미지 출처(ravendb.net)</a></p>

<p>왼쪽은 데이터를 테이블 형태로 나타낸 것, 오른쪽은 문서형태로 나타낸 것입니다. Document Database는 보이는 것 과 같이 데이터를 JSON이나 XML 형태로 저장하는데 테이블 형태와 달리 각 기록(컬렉션)마다 다른 스키마를 가질 수 있습니다.</p>

<p>Document Database는 데이터를 Object형식으로 저장하기 때문에 SQL에 비해 어플리케이션과 데이터에비이스 사이의 translation비용이 적게 듭니다.</p>

<p><br /></p>

<h4 id="3-column-oriented-database-wide-column-database-cassandra-hbase"><strong>3. Column-Oriented Database (Wide Column Database): Cassandra, Hbase</strong></h4>

<p><img src="https://qph.fs.quoracdn.net/main-qimg-c29673c7da88bf898770ef130155e661" alt="Columnar database" /><br />
<a href="https://www.quora.com/What-is-a-columnar-database">이미지 출처(quora.com)</a></p>

<p>위 이미지에서와 같이 행마다 키와 값을 저장할때 각각 다른 값, 다른 수의 스키마를 가질수 있는 데이터베이스 형태입니다.
대량의 데이터에 대한 압축, 분석처리가 빠른 특징이 있습니다.</p>

<p><br /></p>

<h4 id="4-graph-database-neo4j-allegrograph"><strong>4. Graph Database: Neo4J, AllegroGraph</strong></h4>

<p><img src="https://venturebeat.com/wp-content/uploads/2021/02/graph-database-neo4j.png?w=1200&amp;strip=all" alt="Graph Database" />
<a href="https://venturebeat.com/2021/02/08/what-is-a-graph-database/">이미지 출처(venturebeat.com)</a></p>

<p>Graph Database는 data elements간의 관계에 집중한 데이터베이스 형태입니다. 각 element는 node형태로 저장되며 노드 사이의 관계를 edge로 표현합니다.<br />
Graph Database에서의 ‘관계’는 elements 사이의 직접적 연결이기 때문에 복잡한 JOIN문이 필요한 SQL에 비해 처리 속도가 빠르고 유연하며 유지보수가 용이한 특징이 있으며, Social Networks에서 주로 사용됩니다.</p>

<p><br /></p>

<h4 id="nosql의-장점"><strong>NoSQL의 장점</strong></h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">설계가 쉽다</code></strong>: 정해진 스키마가 없기 때문에 자유로운 데이터 구조를 가질 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">구조의 변경이 쉽다</code></strong>: 데이터 구조의 변경이 필요할 떄 언제든 새로운 필드를 추가, 변경할 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">읽기와 쓰기가 빠르다</code></strong>: 데이터가 어플리케이션에 맞는 형태로 저장되기 때문에 읽기와 쓰기 속도가 빠르다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">데이터 분산</code></strong>이 쉬우며 <strong><code class="language-plaintext highlighter-rouge">수평적 확장</code></strong>이 가능하다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">대용량의 데이터 처리</code></strong>에 유리하다.</li>
</ul>

<p><br /></p>

<h4 id="nosql의-단점"><strong>NoSQL의 단점</strong></h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">데이터 수정이 오래 걸린다</code></strong>: 중복된 데이터 변경 시, 모든 컬렉션에서 해당 데이터를 수정해주어야한다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">일관성이 보장되지 않는다</code></strong>: ACID 트랜잭션을 지원하지 않기때문에 데이터의 일관성이 보장되지 않는다.</li>
</ul>

<p><br /></p>

<h3 id="references">References</h3>

<blockquote>
  <p><a href="https://medium.com/@duddk1551/db-rdb-%EA%B4%80%EA%B3%84%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%99%80-nosql-adbd21f6f9f1">zzory_bbong (2019, Apr 30). DB_RDB(관계형데이터베이스)와 NoSQL</a><br />
<a href="https://www.mongodb.com/en-us/nosql-explained">MongoDB. What is NoSQL?</a><br />
<a href="http://www.incodom.kr/NoSQL_DB_%EC%9D%98_%EC%A2%85%EB%A5%98#h_5eb1cd481d082296550e9a66dfae32d1">jmkang (2018, Jul 09). NoSQL DB의 종류</a></p>
</blockquote>]]></content><author><name></name></author><category term="CS" /><summary type="html"><![CDATA[저번 포스팅에 이어 이번에는 NoSQL에 대해 알아보도록 하겠습니다.]]></summary></entry><entry><title type="html">RDBMS와 NoSQL의 차이 - 1부 RDBMS</title><link href="http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS.html" rel="alternate" type="text/html" title="RDBMS와 NoSQL의 차이 - 1부 RDBMS" /><published>2022-01-17T00:00:00+09:00</published><updated>2022-01-17T00:00:00+09:00</updated><id>http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS</id><content type="html" xml:base="http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS.html"><![CDATA[<p>우리는 흔히 데이터를 저장하기 위해서 두가지 유형의 데이터베이스를 사용합니다.</p>

<p><strong>RDBMS</strong>와 <strong>NoSQL</strong>이죠.</p>

<p>이번 포스팅에서는 그 차이에 대해서 알아보도록 할텐데요.</p>

<p>먼저 오늘은 <strong>RDBMS</strong>에 대해 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="rdbms란"><strong>RDBMS란?</strong></h3>
<p><strong>R</strong>elational <strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem의 약자로 관계형 데이터베이스 관리 시스템을 말합니다.</p>

<p>관계형 데이터베이스는 각 역할 별로 Row와 Column으로 이루어진 2차원 테이블을 만들고 관련된 데이터를 정해진 규격에 따라 테이블에  저장하며, 여러 테이블들을 연결하기 위해 <strong>‘관계’</strong>를 사용하는 데이터베이스입니다.</p>

<p>간단한 쇼핑몰 데이터베이스로 예를 들어 보겠습니다.</p>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/rdb.png" alt="rdb" /></p>

<p>위의 예시처럼 각 테이블의 기록(record)마다 고유한 아이디(Primary Key)를 가지고 있고 다른 테이블에서 해당 기록의 정보가 필요할 때에는 정보를 중복 입력하는 것이 아니라, 해당 기록의 Primary Key를 외래 키(Foreign Key)로써 참조하여 테이블과 테이블을 연결해주는 것이 특징입니다.</p>

<p>또한 데이터를 정해진 규격에 따라 저장하기 때문에 위 예시에서 각 테이블의 Field 옆에 명시 된 데이터 타입 이외의 정보는 저장할 수 없습니다.</p>

<p>RDBMS에서는 데이터의 생성, 수정, 삭제, 검색을 위해 SQL (<strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage)이라는 쿼리 언어를 사용합니다.</p>

<p><br /></p>

<blockquote>
  <p>SQL 예시</p>
</blockquote>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">users</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">order_number</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="nb">date</span> <span class="k">as</span> <span class="n">order_date</span><span class="p">,</span> 
<span class="n">category</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">category</span><span class="p">,</span> <span class="n">products</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">product_name</span><span class="p">,</span> <span class="n">order_products</span><span class="p">.</span><span class="n">quantity</span>
<span class="k">FROM</span> <span class="n">users</span> 
<span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">order_products</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">order_products</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">JOIN</span> <span class="n">products</span> <span class="k">ON</span> <span class="n">order_products</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">products</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">category</span> <span class="k">ON</span> <span class="n">products</span><span class="p">.</span><span class="n">category_id</span> <span class="o">=</span> <span class="n">category</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">users</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="s1">'sanghun'</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orders</span><span class="p">.</span><span class="nb">date</span> <span class="k">DESC</span>
</code></pre></div></div>
<p><br /></p>

<blockquote>
  <p>결과 예시</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">username</th>
      <th style="text-align: center">order_number</th>
      <th style="text-align: center">order_date</th>
      <th style="text-align: center">category</th>
      <th style="text-align: center">product_name</th>
      <th style="text-align: center">quantity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">2022-01-19</td>
      <td style="text-align: center">상의</td>
      <td style="text-align: center">무지 반팔티 - 화이트</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">2022-01-19</td>
      <td style="text-align: center">하의</td>
      <td style="text-align: center">기본 와이드 슬랙스</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">2021-01-11</td>
      <td style="text-align: center">아우터</td>
      <td style="text-align: center">양털 후리스</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">2021-01-11</td>
      <td style="text-align: center">모자</td>
      <td style="text-align: center">캐릭터 비니</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="rdbms의-장점"><strong>RDBMS의 장점</strong></h4>
<ul>
  <li>데이터가 규격화 되어있고, 중복이 없기 때문에 <strong><code class="language-plaintext highlighter-rouge">자주 변경</code></strong>되더라도 <strong><code class="language-plaintext highlighter-rouge">작업의 완전성</code></strong>을 보장함.</li>
  <li>데이터의 <strong><code class="language-plaintext highlighter-rouge">분류, 정렬, 탐색 속도가 빠름</code></strong></li>
  <li>ACID 특성으로 데이터의 <strong><code class="language-plaintext highlighter-rouge">일관성, 무결성, 안전성</code></strong>을 보장함.</li>
</ul>

<p><br /></p>

<h4 id="rdbms의-단점"><strong>RDBMS의 단점</strong></h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">초기에 드는 설계 비용이 크다</code></strong>: 데이터베이스의 스키마를 짤 때에 테이블의 <strong>구조</strong>와 <strong>관계</strong> 각 field의 <strong>데이터타입까지</strong> 세세하게 설계해줘야 한다.</li>
  <li>데이터를 다룰 때 반드시 <strong><code class="language-plaintext highlighter-rouge">스키마의 규격에 맞춰야한다</code></strong>. (스키마에 맞지 않는다면 데이터의 저장이 불가능하다.)</li>
  <li>구조를 한번 정한 뒤엔 데이터베이스의 <strong><code class="language-plaintext highlighter-rouge">구조를 변경하기 어렵다</code></strong>.</li>
  <li>서비스의 규모가 커질 경우 <strong><code class="language-plaintext highlighter-rouge">JOIN문이 복잡</code></strong>해질 수 있다.</li>
  <li>RDBMS의 특성상 DB의 확장이 필요할 시 수평적 확장이 어렵고, <strong><code class="language-plaintext highlighter-rouge">수직적 확장</code></strong>만 가능하다. (확장 비용이 비싸다.)</li>
</ul>

<p><br /></p>

<p><strong>*수직적 확장과 수평적 확장</strong></p>
<ul>
  <li>수직적 확장 (Scale Up): 서버의 하드웨어(CPU, RAM 등) 성능을 업그레이드하는 방식</li>
  <li>수평적 확장 (Scale Out): 서버를 더 추가해서 분산처리하는 방식</li>
</ul>

<p><br /></p>

<h3 id="references">References</h3>

<blockquote>
  <p><a href="https://universitytomorrow.com/26">ghostzoominn (2020, Sep 14). RDBMS와 NoSQL의 차이점 완벽 정리.</a><br />
<a href="https://devuna.tistory.com/25">devuna (2020, Feb 13). [DB]SQL(관계형 데이터베이스)과 NoSQL(비 관계형 데이터베이스) 개념/비교/차이.</a></p>
</blockquote>]]></content><author><name></name></author><category term="CS" /><summary type="html"><![CDATA[우리는 흔히 데이터를 저장하기 위해서 두가지 유형의 데이터베이스를 사용합니다.]]></summary></entry><entry><title type="html">프로세스와 스레드의 차이</title><link href="http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html" rel="alternate" type="text/html" title="프로세스와 스레드의 차이" /><published>2022-01-11T17:25:53+09:00</published><updated>2022-01-11T17:25:53+09:00</updated><id>http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4</id><content type="html" xml:base="http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html"><![CDATA[<p><br />
기술면접을 보다보면 열에 아홉은 꼭 나오는 주제들이 있습니다.</p>

<p>이 주제도 그동안 면접을 보면서 직접적으로나 간접적으로 자주 마주친 주제 중 하나입니다.</p>

<p><br /></p>

<blockquote>
  <h3 id="목차">목차</h3>
  <ul>
    <li><a href="#프로세스-vs-스레드">프로세스 vs 스레드</a>
      <ul>
        <li><a href="#프로세스">프로세스</a></li>
        <li><a href="#스레드">스레드</a></li>
      </ul>
    </li>
    <li><a href="#멀티프로세스-vs-멀티스레드">멀티프로세스 vs 멀티스레드</a>
      <ul>
        <li><a href="#멀티프로세스">멀티프로세스</a></li>
        <li><a href="#멀티스레드">멀티스레드</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br />
<br /></p>
<h2 id="프로세스-vs-스레드">프로세스 vs 스레드</h2>

<hr />

<p><br /></p>

<h3 id="프로세스">프로세스</h3>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/Process.png" alt="프로세스" /></p>

<ul>
  <li>프로그램이 실행되어 운영체제에게 자원을 할당받은 작업의 단위</li>
  <li>각 프로세스는 독립적인 주소공간을 할당 받기 때문에 서로의 자원에 직접 접근할 수 없고, 접근하기 위해서는 IPC(inter-process communication)를 사용해야 한다.</li>
  <li>프로세스는 최소 1개 이상의 스레드를 가지고 있다. (첫 번째 스레드를 메인스레드라 부른다.)</li>
</ul>

<p><br /></p>

<h3 id="스레드">스레드</h3>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/Thread.png" alt="스레드" /></p>

<ul>
  <li>한 작업(프로세스) 내에서 실행되는 여러 흐름의 단위</li>
  <li>즉, 스레드는 프로세스에 포함되어 있다.</li>
  <li>스레드는 Stack영역을 제외한 프로세스의 자원을 공유한다.</li>
</ul>

<p><br /></p>
<h2 id="멀티프로세스-vs-멀티스레드">멀티프로세스 vs 멀티스레드</h2>
<hr />

<p><br /></p>

<p>우리가 흔히 컴퓨터를 사용할 때를 생각해보면 한가지의 프로그램만 사용하지는 않습니다. YouTube로 Lofi 음악도 틀어놓고, VS code로 코딩을 하면서, Slack이나 Discord로 간간이 메세지도 보내죠! 이 모든 프로그램이 동시에 돌아가고 있는 것 같지만 사실 컴퓨터는 한번에 한가지의 일만 처리할 수 있습니다. 그렇다면 우리는 어떻게 동시에 여러 프로그램을 사용할 수 있는걸까요?</p>

<p>바로 <strong>*Context Switching</strong>을 통해 여러개의 프로세스를 우리가 느끼지 못할 찰나의 시간 안에 지속적으로 바꿔가며 처리를 하기 때문에 동시에 사용하고 있는 것처럼 느껴지게 만들기 때문입니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>*Context Switching 이란?</strong> : CPU가 여러 프로세스를 처리할 때, 현재 프로세스의 상태(Context)를 해당 프로세스의 PCB(Process Control Block)에 저장하고, 대기중이던 다음 프로세스의 상태(Context)를 불러오는 과정</p>
</blockquote>

<p><br /></p>

<p>하나의 컴퓨터 안에서 여러개의 프로그램이 동시에 돌아가기도 하지만, 더 자세히 들여다 보면 하나의 프로그램 안에서 여러개의 작업이 동시에 처리되어야 하는 경우도 많습니다. 그런 경우에 <strong>멀티프로세스</strong>나 <strong>멀티스레드</strong>를 이용하는데 두가지의 차이점에 대해서 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="멀티프로세스">멀티프로세스</h3>
<ul>
  <li>하나의 프로그램을 여러개의 <strong>프로세스</strong>로 구성하여 동시에 여러개의 작업을 수행하는 방식</li>
</ul>

<blockquote>
  <p><strong>장점</strong></p>
  <ul>
    <li><strong>안전성이 높다</strong>: 하나의 자식 프로세스에서 문제가 발생하더라도, 프로세스는 서로 독립되어 있기 때문에 다른 작업들에는 영향을 끼치지 않는다.<br /></li>
  </ul>

  <p><strong>단점</strong></p>
  <ul>
    <li>
      <p><strong>Context Switching에서의 오버헤드</strong>: 프로세스간의 Context Switching 과정에서는 정보를 저장하고 불러오는 것과 더불어 캐쉬 메모리까지 초기화 해야하기 때문에 오버헤드가 발생한다.</p>
    </li>
    <li>
      <p><strong>자원 공유 과정의 오버헤드</strong>: 스레드와는 달리 각각의 프로세스는 독립된 메모리 공간을 가지기 때문에 전역변수 등 자원의 공유가 필요할 때에 IPC와 같은 복잡한 통신방법으로 인해 오버헤드가 발생한다.</p>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h3 id="멀티스레드">멀티스레드</h3>
<ul>
  <li>하나의 프로그램을 여러개의 <strong>스레드</strong>로 구성하여 동시에 여러개의 작업을 수행하는 방식</li>
</ul>

<blockquote>
  <p><strong>장점</strong></p>
  <ul>
    <li>
      <p><strong>시스템 자원 소모 감소</strong>: 멀티프로세스에 비해 프로세스를 생성하는 시스템 콜이 줄어들어 메모리 등 자원의 소모가 줄어든다.</p>
    </li>
    <li>
      <p><strong>스레드간 자원 공유로 인한 처리 속도 증가</strong>: 스레드끼리는 Stack영역을 제외한 나머지 자원들을 공유하므로 Context Switching의 비용도 현저히 줄고, 스레드간 통신의 부담 또한 적다.</p>
    </li>
  </ul>

  <p><strong>단점</strong></p>
  <ul>
    <li>
      <p><strong>안전성이 낮다</strong>: 모든 스레드가 자원을 공유하기 때문에 하나의 스레드에서 문제가 일어날 경우, 영향이 전체 프로세스로 확산될 수 있다.</p>
    </li>
    <li>
      <p><strong>동기화 문제</strong>: 여러 스레드가 하나의 자원에 동시에 접근할 경우 충돌이 발생할 수 있다. 따라서 동기화를 통해 자원에 대한 접근 권한이나 접근 순서를 지정해 주어야 한다.</p>
    </li>
    <li>
      <p><strong>디버깅이 까다롭다</strong>: 동기화 문제와 마찬가지로 여러 스레드가 자원을 공유하기 때문에 에러가 발생했을 때 디버깅이 어렵다.</p>
    </li>
  </ul>
</blockquote>

<p><br />
<br /></p>

<h3 id="references">References</h3>

<blockquote>
  <p><a href="https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html">권희정 (2018, Sep 14). 프로세스와 스레드의 차이. Heee’s Development Blog.</a><br />
<a href="https://brunch.co.kr/@kd4/3">강관우 (2016, May 07). 프로세스와 스레드의 차이. 개발자 지망생 (Brunch Magazine).</a><br />
<a href="https://pearlluck.tistory.com/150">godpearl (2020, May 10). 컨텍스트 스위칭 (Context Switching) 개념정리. 그럼에도 불구하고.</a></p>
</blockquote>]]></content><author><name></name></author><category term="CS" /><summary type="html"><![CDATA[기술면접을 보다보면 열에 아홉은 꼭 나오는 주제들이 있습니다.]]></summary></entry></feed>