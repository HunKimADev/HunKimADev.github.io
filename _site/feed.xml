<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-19T19:57:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hoolie’s Tech Blog</title><subtitle>공부하고 까먹지 않기 위해 정리해 나가는 개발 블로그</subtitle><entry><title type="html">RDBMS와 NoSQL의 차이 - 1부 RDBMS</title><link href="http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS.html" rel="alternate" type="text/html" title="RDBMS와 NoSQL의 차이 - 1부 RDBMS" /><published>2022-01-17T00:00:00+09:00</published><updated>2022-01-17T00:00:00+09:00</updated><id>http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS</id><content type="html" xml:base="http://localhost:4000/cs/2022/01/17/RDBMS%EC%99%80-NoSQL%EC%9D%98-%EC%B0%A8%EC%9D%B4-1%EB%B6%80-RDBMS.html"><![CDATA[<p>우리는 흔히 데이터를 저장하기 위해서 두가지 유형의 데이터베이스를 사용합니다.</p>

<p><strong>RDBMS</strong>와 <strong>NoSQL</strong>이죠.</p>

<p>이번 포스팅에서는 그 차이에 대해서 알아보도록 할텐데요.</p>

<p>먼저 오늘은 <strong>RDBMS</strong>에 대해 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="rdbms란"><strong>RDBMS란?</strong></h3>
<p><strong>R</strong>elational <strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem의 약자로 관계형 데이터베이스 관리 시스템을 말합니다.</p>

<p>관계형 데이터베이스는 각 역할 별로 Row와 Column으로 이루어진 2차원 테이블을 만들고 관련된 데이터를 정해진 규격에 따라 테이블에  저장하며, 여러 테이블들을 연결하기 위해 <strong>‘관계’</strong>를 사용하는 데이터베이스입니다.</p>

<p>간단한 쇼핑몰 데이터베이스로 예를 들어 보겠습니다.</p>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/rdb.png" alt="rdb" /></p>

<p>위의 예시처럼 각 테이블의 기록(record)마다 고유한 아이디(Primary Key)를 가지고 있고 다른 테이블에서 해당 기록의 정보가 필요할 때에는 정보를 중복 입력하는 것이 아니라, 해당 기록의 Primary Key를 외래 키(Foreign Key)로써 참조하여 테이블과 테이블을 연결해주는 것이 특징입니다.</p>

<p>또한 데이터를 정해진 규격에 따라 저장하기 때문에 위 예시에서 각 테이블의 Field 옆에 명시 된 데이터 타입 이외의 정보는 저장할 수 없습니다.</p>

<p>RDBMS에서는 데이터의 생성, 수정, 삭제, 검색을 위해 SQL (<strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage)이라는 쿼리 언어를 사용합니다.</p>

<p><br /></p>

<blockquote>
  <p>SQL 예시</p>
</blockquote>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">users</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">order_number</span><span class="p">,</span> <span class="n">orders</span><span class="p">.</span><span class="nb">date</span> <span class="k">as</span> <span class="n">order_date</span><span class="p">,</span> 
<span class="n">category</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">category</span><span class="p">,</span> <span class="n">products</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">product_name</span><span class="p">,</span> <span class="n">order_products</span><span class="p">.</span><span class="n">quantity</span>
<span class="k">FROM</span> <span class="n">users</span> 
<span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">order_products</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">order_products</span><span class="p">.</span><span class="n">order_id</span>
<span class="k">JOIN</span> <span class="n">products</span> <span class="k">ON</span> <span class="n">order_products</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">products</span><span class="p">.</span><span class="n">id</span>
<span class="k">JOIN</span> <span class="n">category</span> <span class="k">ON</span> <span class="n">products</span><span class="p">.</span><span class="n">category_id</span> <span class="o">=</span> <span class="n">category</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">users</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="s1">'sanghun'</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">orders</span><span class="p">.</span><span class="nb">date</span> <span class="k">DESC</span>
</code></pre></div></div>
<p><br /></p>

<blockquote>
  <p>결과 예시</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">username</th>
      <th style="text-align: center">order_number</th>
      <th style="text-align: center">order_date</th>
      <th style="text-align: center">category</th>
      <th style="text-align: center">product_name</th>
      <th style="text-align: center">quantity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">2022-01-19</td>
      <td style="text-align: center">상의</td>
      <td style="text-align: center">무지 반팔티 - 화이트</td>
      <td style="text-align: center">3</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">2022-01-19</td>
      <td style="text-align: center">하의</td>
      <td style="text-align: center">기본 와이드 슬랙스</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">2021-01-11</td>
      <td style="text-align: center">아우터</td>
      <td style="text-align: center">양털 후리스</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">sanghun</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">2021-01-11</td>
      <td style="text-align: center">모자</td>
      <td style="text-align: center">캐릭터 비니</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="rdbms의-장점"><strong>RDBMS의 장점</strong></h4>
<ul>
  <li>데이터가 규격화 되어있고, 중복이 없기 때문에 <strong>자주 변경</strong>되더라도 <strong>작업의 완전성</strong>을 보장함.</li>
  <li>데이터의 <strong>분류, 정렬, 탐색 속도가 빠름</strong></li>
  <li>ACID 특성으로 데이터의 <strong>일관성, 무결성, 안전성</strong>을 보장함.</li>
</ul>

<p><br /></p>

<h4 id="rdbms의-단점"><strong>RDBMS의 단점</strong></h4>
<ul>
  <li><strong>초기에 드는 설계 비용이 크다</strong>: 데이터베이스의 스키마를 짤 때에 테이블의 <strong>구조</strong>와 <strong>관계</strong> 각 field의 <strong>데이터타입까지</strong> 세세하게 설계해줘야 한다.</li>
  <li>데이터를 다룰 때 반드시 <strong>스키마의 규격에 맞춰야한다</strong>. (스키마에 맞지 않는다면 데이터의 저장이 불가능하다.)</li>
  <li>구조를 한번 정한 뒤엔 데이터베이스의 <strong>구조를 변경하기 어렵다</strong>.</li>
  <li>서비스의 규모가 커질 경우 <strong>JOIN문이 복잡</strong>해질 수 있다.</li>
  <li>RDBMS의 특성상 DB의 확장이 필요할 시 수평적 확장이 어렵고, <strong>수직적 확장</strong>만 가능하다. (확장 비용이 비싸다.)</li>
</ul>

<p><br /></p>

<p><strong>*수직적 확장과 수평적 확장</strong></p>
<ul>
  <li>수직적 확장 (Scale Up): 서버의 하드웨어(CPU, RAM 등) 성능을 업그레이드하는 방식</li>
  <li>수평적 확장 (Scale Out): 서버를 더 추가해서 분산처리하는 방식</li>
</ul>

<p><br /></p>

<h3 id="references">References</h3>

<blockquote>
  <p><a href="https://universitytomorrow.com/26">ghostzoominn (2020, Sep 14). RDBMS와 NoSQL의 차이점 완벽 정리.</a><br />
<a href="https://devuna.tistory.com/25">devuna (2020, Feb 13). [DB]SQL(관계형 데이터베이스)과 NoSQL(비 관계형 데이터베이스) 개념/비교/차이.</a></p>
</blockquote>]]></content><author><name></name></author><category term="CS" /><summary type="html"><![CDATA[우리는 흔히 데이터를 저장하기 위해서 두가지 유형의 데이터베이스를 사용합니다.]]></summary></entry><entry><title type="html">프로세스와 스레드의 차이</title><link href="http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html" rel="alternate" type="text/html" title="프로세스와 스레드의 차이" /><published>2022-01-11T17:25:53+09:00</published><updated>2022-01-11T17:25:53+09:00</updated><id>http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4</id><content type="html" xml:base="http://localhost:4000/cs/2022/01/11/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4.html"><![CDATA[<p><br />
기술면접을 보다보면 열에 아홉은 꼭 나오는 주제들이 있습니다.</p>

<p>이 주제도 그동안 면접을 보면서 직접적으로나 간접적으로 자주 마주친 주제 중 하나입니다.</p>

<p><br /></p>

<blockquote>
  <h3 id="목차">목차</h3>
  <ul>
    <li><a href="#프로세스-vs-스레드">프로세스 vs 스레드</a>
      <ul>
        <li><a href="#프로세스">프로세스</a></li>
        <li><a href="#스레드">스레드</a></li>
      </ul>
    </li>
    <li><a href="#멀티프로세스-vs-멀티스레드">멀티프로세스 vs 멀티스레드</a>
      <ul>
        <li><a href="#멀티프로세스">멀티프로세스</a></li>
        <li><a href="#멀티스레드">멀티스레드</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><br />
<br /></p>
<h2 id="프로세스-vs-스레드">프로세스 vs 스레드</h2>

<hr />

<p><br /></p>

<h3 id="프로세스">프로세스</h3>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/Process.png" alt="프로세스" /></p>

<ul>
  <li>프로그램이 실행되어 운영체제에게 자원을 할당받은 작업의 단위</li>
  <li>각 프로세스는 독립적인 주소공간을 할당 받기 때문에 서로의 자원에 직접 접근할 수 없고, 접근하기 위해서는 IPC(inter-process communication)를 사용해야 한다.</li>
  <li>프로세스는 최소 1개 이상의 스레드를 가지고 있다. (첫 번째 스레드를 메인스레드라 부른다.)</li>
</ul>

<p><br /></p>

<h3 id="스레드">스레드</h3>

<p><img src="https://sanghun-blog-asset.s3.ap-northeast-2.amazonaws.com/Thread.png" alt="스레드" /></p>

<ul>
  <li>한 작업(프로세스) 내에서 실행되는 여러 흐름의 단위</li>
  <li>즉, 스레드는 프로세스에 포함되어 있다.</li>
  <li>스레드는 Stack영역을 제외한 프로세스의 자원을 공유한다.</li>
</ul>

<p><br /></p>
<h2 id="멀티프로세스-vs-멀티스레드">멀티프로세스 vs 멀티스레드</h2>
<hr />

<p><br /></p>

<p>우리가 흔히 컴퓨터를 사용할 때를 생각해보면 한가지의 프로그램만 사용하지는 않습니다. YouTube로 Lofi 음악도 틀어놓고, VS code로 코딩을 하면서, Slack이나 Discord로 간간이 메세지도 보내죠! 이 모든 프로그램이 동시에 돌아가고 있는 것 같지만 사실 컴퓨터는 한번에 한가지의 일만 처리할 수 있습니다. 그렇다면 우리는 어떻게 동시에 여러 프로그램을 사용할 수 있는걸까요?</p>

<p>바로 <strong>*Context Switching</strong>을 통해 여러개의 프로세스를 우리가 느끼지 못할 찰나의 시간 안에 지속적으로 바꿔가며 처리를 하기 때문에 동시에 사용하고 있는 것처럼 느껴지게 만들기 때문입니다.</p>

<p><br /></p>

<blockquote>
  <p><strong>*Context Switching 이란?</strong> : CPU가 여러 프로세스를 처리할 때, 현재 프로세스의 상태(Context)를 해당 프로세스의 PCB(Process Control Block)에 저장하고, 대기중이던 다음 프로세스의 상태(Context)를 불러오는 과정</p>
</blockquote>

<p><br /></p>

<p>하나의 컴퓨터 안에서 여러개의 프로그램이 동시에 돌아가기도 하지만, 더 자세히 들여다 보면 하나의 프로그램 안에서 여러개의 작업이 동시에 처리되어야 하는 경우도 많습니다. 그런 경우에 <strong>멀티프로세스</strong>나 <strong>멀티스레드</strong>를 이용하는데 두가지의 차이점에 대해서 알아보도록 하겠습니다.</p>

<p><br /></p>

<h3 id="멀티프로세스">멀티프로세스</h3>
<ul>
  <li>하나의 프로그램을 여러개의 <strong>프로세스</strong>로 구성하여 동시에 여러개의 작업을 수행하는 방식</li>
</ul>

<blockquote>
  <p><strong>장점</strong></p>
  <ul>
    <li><strong>안전성이 높다</strong>: 하나의 자식 프로세스에서 문제가 발생하더라도, 프로세스는 서로 독립되어 있기 때문에 다른 작업들에는 영향을 끼치지 않는다.<br /></li>
  </ul>

  <p><strong>단점</strong></p>
  <ul>
    <li>
      <p><strong>Context Switching에서의 오버헤드</strong>: 프로세스간의 Context Switching 과정에서는 정보를 저장하고 불러오는 것과 더불어 캐쉬 메모리까지 초기화 해야하기 때문에 오버헤드가 발생한다.</p>
    </li>
    <li>
      <p><strong>자원 공유 과정의 오버헤드</strong>: 스레드와는 달리 각각의 프로세스는 독립된 메모리 공간을 가지기 때문에 전역변수 등 자원의 공유가 필요할 때에 IPC와 같은 복잡한 통신방법으로 인해 오버헤드가 발생한다.</p>
    </li>
  </ul>
</blockquote>

<p><br /></p>

<h3 id="멀티스레드">멀티스레드</h3>
<ul>
  <li>하나의 프로그램을 여러개의 <strong>스레드</strong>로 구성하여 동시에 여러개의 작업을 수행하는 방식</li>
</ul>

<blockquote>
  <p><strong>장점</strong></p>
  <ul>
    <li>
      <p><strong>시스템 자원 소모 감소</strong>: 멀티프로세스에 비해 프로세스를 생성하는 시스템 콜이 줄어들어 메모리 등 자원의 소모가 줄어든다.</p>
    </li>
    <li>
      <p><strong>스레드간 자원 공유로 인한 처리 속도 증가</strong>: 스레드끼리는 Stack영역을 제외한 나머지 자원들을 공유하므로 Context Switching의 비용도 현저히 줄고, 스레드간 통신의 부담 또한 적다.</p>
    </li>
  </ul>

  <p><strong>단점</strong></p>
  <ul>
    <li>
      <p><strong>안전성이 낮다</strong>: 모든 스레드가 자원을 공유하기 때문에 하나의 스레드에서 문제가 일어날 경우, 영향이 전체 프로세스로 확산될 수 있다.</p>
    </li>
    <li>
      <p><strong>동기화 문제</strong>: 여러 스레드가 하나의 자원에 동시에 접근할 경우 충돌이 발생할 수 있다. 따라서 동기화를 통해 자원에 대한 접근 권한이나 접근 순서를 지정해 주어야 한다.</p>
    </li>
    <li>
      <p><strong>디버깅이 까다롭다</strong>: 동기화 문제와 마찬가지로 여러 스레드가 자원을 공유하기 때문에 에러가 발생했을 때 디버깅이 어렵다.</p>
    </li>
  </ul>
</blockquote>

<p><br />
<br /></p>

<h3 id="references">References</h3>

<blockquote>
  <p><a href="https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html">권희정 (2018, Sep 14). 프로세스와 스레드의 차이. Heee’s Development Blog.</a><br />
<a href="https://brunch.co.kr/@kd4/3">강관우 (2016, May 07). 프로세스와 스레드의 차이. 개발자 지망생 (Brunch Magazine).</a><br />
<a href="https://pearlluck.tistory.com/150">godpearl (2020, May 10). 컨텍스트 스위칭 (Context Switching) 개념정리. 그럼에도 불구하고.</a></p>
</blockquote>]]></content><author><name></name></author><category term="CS" /><summary type="html"><![CDATA[기술면접을 보다보면 열에 아홉은 꼭 나오는 주제들이 있습니다.]]></summary></entry></feed>